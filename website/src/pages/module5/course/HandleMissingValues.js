import React from "react";
import { Container, Row, Col, Table } from "react-bootstrap";
import CodeBlock from "components/CodeBlock";
import DataInteractionPanel from "components/DataInteractionPanel";

const HandleMissingValues = () => {
  const requirementsUrl =
    process.env.PUBLIC_URL + "/modules/module5/course/module5_requirements.txt";
  const DataUrl =
    process.env.PUBLIC_URL +
    "/modules/module5/course/module5_course_handling_missing_values";
  const notebookUrl =
    process.env.PUBLIC_URL +
    "/modules/module5/course/Handling_Missing_Values.ipynb";
  const notebookHtmlUrl =
    process.env.PUBLIC_URL +
    "/modules/module5/course/Handling_Missing_Values.html";
  const notebookColabUrl =
    process.env.PUBLIC_URL +
    "website/public/modules/module5/course/Handling_Missing_Values.ipynb";
  const metadata = {
    description:
      "This dataset contains operational metrics from wind turbines, capturing various aspects of turbine performance and environmental conditions.",
    source: "Wind Energy Monitoring System",
    target: "ActivePower",
    listData: [
      {
        name: "RotorRPM",
        description:
          "Rotational speed of the turbine rotor in revolutions per minute (RPM).",
        dataType: "Float",
        example: "14.2 RPM",
      },
      {
        name: "ReactivePower",
        description:
          "Reactive power generated by the turbine, measured in kilovars (kVAR). Reflects the power that oscillates between the source and the load.",
        dataType: "Float",
        example: "50 kVAR",
      },
      {
        name: "GeneratorRPM",
        description:
          "Rotational speed of the generator in revolutions per minute (RPM).",
        dataType: "Float",
        example: "1500 RPM",
      },
      {
        name: "WindSpeed",
        description:
          "Speed of the wind at hub height, measured in meters per second (m/s).",
        dataType: "Float",
        example: "7.5 m/s",
      },
      {
        name: "Blade1PitchAngle",
        description:
          "Pitch angle of the first blade, which controls the angle of the blades relative to the wind to optimize power generation or minimize wind load.",
        dataType: "Float",
        example: "12.5 degrees",
      },
      {
        name: "AmbientTemperature",
        description:
          "The temperature outside the turbine nacelle, measured in degrees Celsius.",
        dataType: "Float",
        example: "25Â°C",
      },
      {
        name: "ActivePower",
        description:
          "The actual power output generated by the turbine, measured in kilowatts (kW).",
        dataType: "Float",
        example: "2000 kW",
      },
    ],
  };

  const MissingDataExample = () => {
    const data = [
      { id: 1, name: "Alice", age: 28, email: "alice@example.com" },
      { id: 2, name: "Bob", age: null, email: "bob@example.com" },
      { id: 3, name: "Carol", age: 34, email: null },
      { id: 4, name: "Dave", age: null, email: null },
    ];

    return (
      <Table striped>
        <thead>
          <tr>
            <th>ID</th>
            <th>Name</th>
            <th>Age</th>
            <th>Email</th>
          </tr>
        </thead>
        <tbody>
          {data.map((row) => (
            <tr key={row.id}>
              <td>{row.id}</td>
              <td>{row.name}</td>
              <td>
                {row.age === null ? (
                  <em style={{ color: "red" }}>Missing</em>
                ) : (
                  row.age
                )}
              </td>
              <td>
                {row.email === null ? (
                  <em style={{ color: "red" }}>Missing</em>
                ) : (
                  row.email
                )}
              </td>
            </tr>
          ))}
        </tbody>
      </Table>
    );
  };
  return (
    <Container fluid>
      <h1 className="my-4">Handling Missing Values</h1>

      <Row>
        <Col>
          <h2 id="what-are-missing-values">What are Missing Values?</h2>
          <p>
            Missing values occur when no data is stored for a variable (feature)
            in an observation. They can appear as 'NaN', 'None', or blanks in
            datasets. Understanding the nature of missing data is crucial for
            making informed decisions on how to handle them.
          </p>
          <p>
            <strong>Reasons for Missing Data:</strong>
            <ul>
              <li>
                <strong>Data not collected:</strong> Information might not be
                collected, either due to oversight or because it was not
                available.
              </li>
              <li>
                <strong>Data collection errors:</strong> Errors in data entry or
                collection processes can lead to missing values.
              </li>
              <li>
                <strong>Data corruption:</strong> During data transfer or
                storage, data might get corrupted leading to missing entries.
              </li>
            </ul>
          </p>
          <MissingDataExample></MissingDataExample>
          <h2 id="visualize-missing-values">Visualize Missing Values</h2>
          <p>
            Visualizing missing data is crucial for understanding the patterns
            of missingness and deciding on appropriate imputation methods.
            Visual techniques can highlight whether the data is missing at
            random, missing completely at random, or missing not at random,
            which can significantly influence your handling strategy.
          </p>
          <CodeBlock
            language={"python"}
            code={`import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

# Assuming df is your DataFrame
# Heatmap to show where missing values occur
plt.figure(figsize=(12, 8))
sns.heatmap(df.isnull(), cbar=False, cmap='viridis')
plt.title('Heatmap of Missing Values')
plt.show()

# Bar chart for missing values count
missing_counts = df.isnull().sum().sort_values(ascending=False)
missing_counts = missing_counts[missing_counts > 0]
plt.figure(figsize=(10, 6))
missing_counts.plot(kind='bar')
plt.title('Bar Chart of Missing Values Count')
plt.xlabel('Columns')
plt.ylabel('Number of Missing Values')
plt.show()`}
          />

          <p>
            The heatmap provides a quick visual overview, showing the presence
            of missing data across different columns and rows. Columns or rows
            with no missing data will be consistently one color, while those
            with missing data will show differently colored patches. This
            visualization helps in quickly identifying patterns or correlations
            in missing data across the dataset.
          </p>
          <p>
            The bar chart complements the heatmap by quantifying the exact
            number of missing entries per feature, allowing you to prioritize
            which columns might need more attention either for further
            investigation or for more sophisticated imputation techniques.
          </p>

          <h2 id="imputation">Mean/Median/Mode Imputation</h2>
          <p>
            Missing values can often be imputed using central tendency measures
            such as the mean, median, or mode. This is one of the simplest
            methods and is particularly effective when the data does not exhibit
            high variance.
          </p>
          <CodeBlock
            language={"python"}
            code={`import pandas as pd

df_filled = df.apply(lambda x: x.fillna(x.mean()), axis=0)`}
          />

          <h2 id="forward-fill">Forward Fill</h2>
          <p>
            For time series data, you might consider using methods like forward
            fill where you propagate the last observed data point to the next
            missing value.
          </p>
          <CodeBlock
            language={"python"}
            code={`# Using pandas for forward fill
import pandas as pd

# Assuming df is your DataFrame
df_filled = df.fillna(method='ffill')`}
          />

          <h2 id="k-nearest-neighbors">K-Nearest Neighbors</h2>
          <p>
            K-Nearest Neighbors can be used to impute missing values based on
            the similarities between features. It is more sophisticated than
            mean/median imputation and can provide more accurate results for
            complex datasets.
          </p>
          <CodeBlock
            language={"python"}
            code={`from sklearn.impute import KNNImputer

imputer = KNNImputer(n_neighbors=5)
X_filled = imputer.fit_transform(X)`}
          />

          <h2 id="predictive-imputation">Predictive Imputation</h2>
          <p>
            Predictive models, such as regression, can also be used to predict
            and impute missing values based on other available data.
          </p>
          <CodeBlock
            language={"python"}
            code={`from sklearn.experimental import enable_iterative_imputer
from sklearn.impute import IterativeImputer
from sklearn.linear_model import BayesianRidge

imp = IterativeImputer(estimator=BayesianRidge(), random_state=0)
X_imputed = imp.fit_transform(X)`}
          />

          <h2 id="is_missing">Adding a 'is_missing' Column</h2>
          <p>
            Sometimes, it's informative to keep track of where data was missing,
            as the missingness itself might be a useful feature.
          </p>
          <CodeBlock
            language={"python"}
            code={`# Using pandas to add a 'is_missing' column
import pandas as pd

df['is_missing'] = df['your_column'].isnull()`}
          />
        </Col>
      </Row>
      <Row>
        <div id="notebook-example"></div>
        <DataInteractionPanel
          DataUrl={DataUrl}
          notebookUrl={notebookUrl}
          notebookHtmlUrl={notebookHtmlUrl}
          notebookColabUrl={notebookColabUrl}
          requirementsUrl={requirementsUrl}
          metadata={metadata}
        />
      </Row>
    </Container>
  );
};

export default HandleMissingValues;
